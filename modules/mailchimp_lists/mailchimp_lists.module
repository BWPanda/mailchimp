<?php

/**
 * @file
 * Mailchimp lists module.
 */
module_load_include('inc', 'mailchimp_lists', 'includes/mailchimp_lists.field');

/**
 * Implements hook_menu().
 */
function mailchimp_lists_menu() {
  $items = array();

  $items['admin/config/services/mailchimp/lists'] = array(
    'title' => 'Lists',
    'description' => 'Display MailChimp Lists and configure Webhooks.',
    'page callback' => 'mailchimp_lists_overview_page',
    'access arguments' => array('administer mailchimp'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/mailchimp_lists.admin.inc',
    'weight' => 10,
  );
  $items['admin/config/services/mailchimp/lists/%/webhook/%'] = array(
    'title' => 'Enable/disable Webhooks',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mailchimp_lists_webhook_form', 5, 7),
    'access arguments' => array('administer mailchimp'),
    'file' => 'includes/mailchimp_lists.admin.inc',
  );


  return $items;
}

/**
 * Implements hook_entity_delete().
 */
function mailchimp_lists_entity_delete($entity, $type) {
  // Check for mailchimp subscription fields and unsubscribe accordingly.
  $fields = field_info_fields();
  foreach($fields as $field) {
    if ($field['type'] == 'mailchimp_lists_subscription' && in_array($entity->type, $field['bundles'][$type])) {
      $config = field_info_instance($type, $field['field_name'], $entity->type);
      mailchimp_lists_process_subscribe_form_choices(array('subscribe' => FALSE), $config, $entity);
    }
  }
}

/**
 * Return a form element for a single newsletter.
 */
function mailchimp_lists_subscribe_form($form, &$form_state, $instance, $settings, $entity, $field) {
  $mc_list = mailchimp_get_list($instance['settings']['mc_list_id']);
  $email = mailchimp_lists_load_email($instance, $entity);
  if (!$email) {
    return array();
  }
  // Determine if a user is subscribed to the list.
  $is_subscribed = mailchimp_is_subscribed($mc_list['id'], $email);
  $wrapper_key = 'mailchimp_' . $instance['field_name'];
  $form_state['settings'] = array(
    'wrapper_key' => $wrapper_key,
    'instance' => $instance,
    'entity' => $entity,
  );
  $form[$wrapper_key] = array(
    '#type' => 'container',
    '#tree' => TRUE,
    '#description' => $instance['description'],
    '#attributes' => array(
      'class' => array(
        'mailchimp-newsletter-wrapper',
        'mailchimp-newsletter-' . $instance['field_name'],
      ),
    ),
  );
  // Add the title and description to lists for anonymous users or if requested:
  $form[$wrapper_key]['subscribe'] = array(
    '#type' => 'checkbox',
    '#title' => 'Subscribe',
    '#disabled' => $instance['required'],
    '#required' => $instance['required'],
    '#default_value' => $instance['required'] || $is_subscribed,
  );
  $form[$wrapper_key]['double_opt_in'] = array(
    '#type' => 'hidden',
    '#value' => $field['settings']['double_opt_in'],
  );
  // Present interest groups:
  if ($settings['show_interest_groups']) {
    // Perform test in case error comes back from MCAPI when getting groups:
    if (is_array($mc_list['intgroups'])) {
      $form[$wrapper_key]['interest_groups'] = array(
        '#type' => 'fieldset',
        '#title' => isset($settings['interest_groups_label']) ? t($settings['interest_groups_label']) : t('Interest Groups'),
        '#weight' => 100,
        '#states' => array(
          'invisible' => array(
            ':input[name="' . $wrapper_key . '[subscribe]"]' => array('checked' => FALSE),
          ),
        ),
      );
      $form[$wrapper_key]['interest_groups'] += _mailchimp_lists_interest_groups_form_elements($mc_list, $instance['default_value'][0]['options']['interest_groups'], $email);
    }
  }
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
  );
  return $form;
}

/**
 * Submit handler to add emails to lists when editing/creating an entity.
 */
function mailchimp_lists_subscribe_form_submit($form, &$form_state) {
  mailchimp_lists_process_subscribe_form_choices(
    $form_state['values'][$form_state['settings']['wrapper_key']],
    $form_state['settings']['instance'], 
    $form_state['settings']['entity']);
}

/**
 * Processor for various list form submissions.
 *
 * Subscription blocks, user settings, and new user creation.
 * 
 * @array $list_forms: an array of mailchimp_list form values, as generated
 *   by mailchimp_lists_list_form() 
 * @account null $account: the user account to subscribe, if available.
 *   Otherwise, operations will be run with the ['mergevars']['EMAIL'] value.
 */
function mailchimp_lists_process_subscribe_form_choices($choices, $instance, $entity) {
  $email = mailchimp_lists_load_email($instance, $entity);
  if (!$email) {
    // We can't do much subscribing without an email address.
    return;
  }
  $function = FALSE;
  $list_id = $instance['settings']['mc_list_id'];
  $subscribed = mailchimp_is_subscribed($list_id, $email);
  if ($choices['subscribe'] != $subscribed) {
    // Subscription selection has changed.
    if ($choices['subscribe']) {
      $function = 'add';
    }
    else {
      $function = 'remove';
    }
  }
  elseif($choices['subscribe']) {
    $function = 'update';
  }
  if ($function) {
    if ($function == 'remove') {
      $mergevars = array();
    }
    else {
      $mergevars = _mailchimp_lists_mergevars_populate($instance['settings']['mergefields'], $entity, $instance['entity_type']);
      if (!empty($choices['interest_groups'])) {
        $mergevars['GROUPINGS'] = _mailchimp_lists_reformat_groupings($choices['interest_groups']);
      }
    }
    switch ($function) {
      case 'add':
        $ret = mailchimp_subscribe($instance['settings']['mc_list_id'], $email, $mergevars, 'html', $choices['double_opt_in']);
        break;

      case 'remove':
        $ret = mailchimp_unsubscribe($instance['settings']['mc_list_id'], $email, TRUE);
        break;

      case 'update':
        $ret = mailchimp_update_member($instance['settings']['mc_list_id'], $email, $mergevars);
        break;
    }
    if (empty($ret)) {
      drupal_set_message(t('There was a problem with your newsletter signup.', 'warning'));
    }
  }
}


/**
 * Helper function to complete a mailchimp api ready mergevars array.
 */
function _mailchimp_lists_mergevars_populate($mergefields, $entity, $entity_type) {
  $wrapper = entity_metadata_wrapper($entity_type, $entity);
  $mergevars = array();
  foreach($mergefields as $label => $property) {
    if (!empty($property) && strlen($property)) {
      $mergevars[$label] = $wrapper->{$property}->value();
    }
  }
  drupal_alter('mailchimp_lists_mergevars', $mergevars, $entity, $entity_type);
  return $mergevars;
}

/**
 * Helper function to generate form elements for a lists interest groups.
 * 
 * @array $mc_list
 *   Fully loaded array with mailchimp list settings as returned by
 *   mailchimp_get_list()
 * @array $default_values
 *   Array of default values to use if no group subscription values already
 *   exist at Mailchimp.
 * @string $email
 *   Optional email address to pass to the MCAPI and retrieve existing values
 *   for use as defaults.
 * @return array
 *   A collection of form elements, one per interest group.
 */
function _mailchimp_lists_interest_groups_form_elements($mc_list, $default_values = array(), $email = NULL) {
  $return = array();
  foreach ($mc_list['intgroups'] as $group) {
    if ($group['form_field'] == 'hidden') {
      continue;
    }
    // Set the form field type:
    switch ($group['form_field']) {
      case 'radio':
        $field_type = 'radios';
        break;

      case 'dropdown':
        $field_type = 'select';
        break;

      default:
        $field_type = $group['form_field'];
    }

    // Extract the field options:
    $options = array();
    foreach ($group['groups'] as $option) {
      $options[$option['name']] = $option['name'];
    }
    // Grab the default values for this group:
    if ($email) {
      $memberinfo = mailchimp_get_memberinfo($mc_list['id'], $email);
      if (isset($memberinfo['merges']['GROUPINGS'])) {
        $default_values = array();
        foreach ($memberinfo['merges']['GROUPINGS'] as $membergroup) {
          if ($membergroup['id'] == $group['id']) {
            foreach($membergroup['groups'] as $option) {
              if ($option['interested']) {
                $default_values[$group['id']][] = $option['name'];
              }
            }
            break;
          }
        }
      }
    }
    $return[$group['id']] = array(
      '#type' => $field_type,
      '#title' => $group['name'],
      '#options' => $options,
      '#default_value' => isset($default_values[$group['id']]) ? $default_values[$group['id']] : array(),
      '#attributes' => array('class' => array('mailchimp-newsletter-interests-' . $mc_list['id'])),
    );
  }
  return $return;
}

/**
 * Helper function to check if a valid email is configured for an entity field.
 * 
 * Returns an email address or FALSE.
 */
function mailchimp_lists_load_email($instance, $entity, $log_errors = TRUE) {
  $entity_wrapper = entity_metadata_wrapper($instance['entity_type'], $entity);
  if (!isset($instance['settings']['mergefields']['EMAIL'])) {
    if ($log_errors) {
      watchdog('mailchimp_lists', 'Mailchimp Lists field "@field" on @entity -> @bundle has no EMAIL field configured, subscription actions cannot take place.', array(
        '@field' => $field['field_name'],
        '@entity' => $entity_type,
        '@bundle' => $instance['bundle'],
      ), WATCHDOG_NOTICE);
    }
    return FALSE;
  }
  $email = $entity_wrapper->{$instance['settings']['mergefields']['EMAIL']}->value();
  // @todo: more stringent email verification.
  if (strlen($email)) {
    return $email;
  }
  else {
    return FALSE;
  }
}


/**
 * Calls the corresponding API function, or adds to the queue, as appropriate.
 * 
 * @string $function - 'add', 'remove', or 'update'. Matches Queue operations.
 * @mailchimp_lists $list - the list to update 
 * @string $mail - email address to update on the list
 * @array $mergevars - merge variables array formatted for mailchimp API
 * @account null $account - account that $mail came from, if non-anonymous call
 * @mcapi_entity null &$mcapi - api object if loaded, to avoid extra API calls
 * @queue null &$queue - the cron queue. If passed, this will force use of cron.
 * 
 * @return <boolean>
 *   Indicates whether the operation was successful.
 */
function mailchimp_lists_execute_change($function, $list, $mail, $mergevars = NULL, $mcapi = NULL, &$queue = NULL) {

  if (empty($mcapi)) {
    $mcapi = mailchimp_get_api_object();
  }
  switch ($function) {
    case 'add':
      $ret = mailchimp_subscribe($list, $mail, $mergevars, 'html', FALSE, TRUE, TRUE, TRUE, $mcapi);
      break;

    case 'remove':
      $ret = mailchimp_unsubscribe($list, $mail, TRUE, FALSE, FALSE, $mcapi);
      break;

    case 'update':
      $ret = mailchimp_update_member($list, $mail, $mergevars, '', TRUE, $mcapi);
      break;
  }
  return $ret;
  
  // If cron is enabled for this list, queue the function.
  if ($list->settings['cron'] || isset($queue)) {
    if (!isset($queue)) {
      $queue = DrupalQueue::get(MAILCHIMP_QUEUE_CRON);
      $queue->createQueue();
    }
    $queue->createItem(array(
      'uid' => isset($account) ? $account->uid : NULL,
      'email' => $mail,
      'list_id' => $list->id,
      'op' => $function,
      'groupings' => isset($mergevars['GROUPINGS']) ? $mergevars['GROUPINGS'] : NULL,
    ));
    $ret = TRUE;
  }
  // If we aren't queueing, we run the operation immediately.
  else {
    if (empty($mcapi)) {
      $mcapi = mailchimp_get_api_object();
    }
    switch ($function) {
      case 'add':
        $ret = mailchimp_subscribe_user($list, $mail, $mergevars, TRUE, $mcapi);
        break;

      case 'remove':
        $ret = mailchimp_unsubscribe_user($list, $mail, TRUE, $mcapi);
        break;

      case 'update':
        $ret = mailchimp_update_user($list, $mail, $mergevars, TRUE, $mcapi);
        break;

    }
  }

  return $ret;
}

/**
 * Helper function to make an API-ready array from an interest group form.
 */
function _mailchimp_lists_reformat_groupings($interest_groups) {
  $groupings = array();
  foreach ($interest_groups as $key => $groups) {
    $groups = array_filter($groups);
    $groupings[] = array('id' => $key, 'groups' => $groups);
  }
  return $groupings;
}

/**
 * Implements hook_mollom_form_list().
 *
 * Enable Mollom integration for user subscription forms.
 */
function mailchimp_lists_mollom_form_list() {
  $forms = array();
  $forms['mailchimp_lists_subscribe_form'] = array(
    'title' => t('Mailchimp Newsletter Subscription Fields'),
  );

  return $forms;
}

/**
 * Implements hook_mollom_form_info().
 */
function mailchimp_lists_mollom_form_info($form_id) {
  // Set mollom form info.
  $form_info = array(
    'bypass access' => array('administer mailchimp'),
    'mode' => MOLLOM_MODE_CAPTCHA,
  );

  return $form_info;
}

/**
 * Return all possible Drupal properties for a given entity type.
 *
 * @param string $entity_type
 *   Name of entity whose properties to list.
 * @param string $entity_bundle
 *   Optional bundle to limit available properties.
 *
 * @return array
 *   List of properties that can be used as an #options list.
 */
function mailchimp_lists_fieldmap_options($entity_type, $entity_bundle = NULL) {
  $options = array('' => t('-- Select --'));

  $properties = entity_get_all_property_info($entity_type);
  if (isset($entity_bundle)) {
    $info = entity_get_property_info($entity_type);
    $properties = $info['properties'];
    if (isset($info['bundles'][$entity_bundle])) {
      $properties += $info['bundles'][$entity_bundle]['properties'];
    }
  }

  foreach ($properties as $key => $property) {
    $type = isset($property['type']) ? entity_property_extract_innermost_type($property['type']) : 'text';
    $is_entity = ($type == 'entity') || (bool) entity_get_info($type);
    // Leave entities out of this.
    if (!$is_entity) {
      if (isset($property['field']) && $property['field'] && !empty($property['property info'])) {
        foreach ($property['property info'] as $sub_key => $sub_prop) {
          $options[$property['label']][$key . ':' . $sub_key] = $sub_prop['label'];
        }
      }
      else {
        $options[$key] = $property['label'];
      }
    }
  }
  return $options;
}
